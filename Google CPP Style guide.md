# 头文件

## The #define Guard
所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: <PROJECT>_<PATH>_<FILE>_H_ .
```
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
```
## 前置声明
尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
前置声明隐藏了实现，有时候会出现问题


## 内联函数
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
## #include 的路径及顺序
使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.

# 作用域
## 命名空间
鼓励在 .cc 文件内使用匿名命名空间或 static 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。
## 匿名命名空间和静态变量
在 .cc 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。但是不要在 .h 文件中这么做。
## 非成员函数、静态成员函数和全局函数
使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.
## 局部变量
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
## 静态和全局变量
禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。

# 类
不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.
## 隐式类型转换
不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字.
## 可拷贝类型和可移动类型
如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.
## 结构体 VS. 类
仅当只有数据成员时使用 struct, 其它一概使用 class.
## 继承
使用组合 (YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.
## 多重继承
真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.
## 接口
接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).
## 运算符重载
除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.
## 存取控制
将 所有 数据成员声明为 private, 除非是 static const 类型成员 (遵循 常量命名规则). 处于技术上的原因, 在使用 Google Test 时我们允许测试固件类中的数据成员为 protected.
## 声明顺序
将相似的声明放在一起, 将 public 部分放在最前.







	